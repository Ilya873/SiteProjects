// определение глобальных переменных
var canvas;
var ctx;
var x = 50; //начальной расположение x
var y = 50; //начальной расположение y
var dx = 0; //начальный импульс x
var dy = 0; //начальный импульс y
var radius = 20; //радиус шара
var gravity = 0.2; //сила гравитации
var friction = 0.05; //сила трения
var bounce = 0.5; //сила отскока
var isMoving = false;
var elem = 0; //0 - шар, 1 - прямоугольник, 2 - треугольник_1, 3 - треугольник_2, 4 - динамит

// функция инициализации
function init() {
  canvas = document.getElementById("canvas");
  ctx = canvas.getContext("2d");
  canvas.width = 500;
  canvas.height = 500;
  drawCircle();
  canvas.addEventListener("click", function(event) {
	 if (!isMoving) {
		 		// Вычисление координат ячейки
let cellX = Math.floor((event.clientX - canvas.offsetLeft) / 100);
let cellY = Math.floor((event.clientY - canvas.offsetTop) / 100);

// Вычисление центра ячейки
let centerX = cellX * 100 + 50;
let centerY = cellY * 100 + 50;
		if (elem === 0)
	{
      x = centerX;
      y = centerY;
      drawCircle();
	}
		if (elem === 1)
	{
		addSquare(centerX, centerY);
		drawWalls();
	}
		if (elem === 2)
	{
		addTriangle_1(centerX, centerY);
		drawWalls();
	}
		if (elem === 3)
	{
		addTriangle_2(centerX, centerY);
		drawWalls();
	}
		if (elem === 4)
	{
		addDynamite(centerX, centerY);
		drawWalls();
	}
	  }
  });
  
canvas.addEventListener("contextmenu", function(event) {
	event.preventDefault(); // предотвращаем открытие контекстного меню браузера
	if (!isMoving) { 
		var mouseX = event.clientX - canvas.offsetLeft;
		var mouseY = event.clientY - canvas.offsetTop;
		// проверяем, находится ли точка клика внутри какой-либо из фигур
		for (var i = 0; i < walls.length; i++) {
			var wall = walls[i];
			if (mouseX >= wall.x && mouseX <= wall.x + wall.width && mouseY >= wall.y && mouseY <= wall.y + wall.height) {
				// удаляем фигуру из массива walls
				walls.splice(i, 1);
				break;
			}
		}
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawCircle();
		drawWalls();
	}
});

document.addEventListener("keydown", function(event) {
  if (event.keyCode === 13 && !isMoving) {
    isMoving = true;
    animate();
  }
});
}

// функция анимации
function animate() {
  if (isMoving) {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawCircle();
	drawWalls();
    x += dx;
    y += dy;
    dy += gravity;

    // определяем, находится ли шар на земле
    var isOnGround = y + radius >= canvas.height;

    // изменяем скорость, если шар на земле
    if (isOnGround) {
      y = canvas.height - radius;
      dy = -dy * bounce;
      dx = dx * (1 - friction);
    }

    // обрабатываем столкновения с границами
    if (x + radius > canvas.width) {
      x = canvas.width - radius;
      dx = -dx * (1 - friction);
    } else if (x - radius < 0) {
      x = radius;
      dx = -dx * (1 - friction);
    }

if (y - radius < 0) {
  y = radius;
  dy = -dy * bounce;
}



    // обрабатываем столкновения со стенами
    for (var i = 0; i < walls.length; i++) {
      var wall = walls[i];
	  // определяем столкновение с обычными прямоугольниками
	  if (wall.shape !== "triangle" && wall.shape !== "dynamite") {
      // определяем расстояние от центра шара до границы стены
      var distX = Math.abs(x - wall.x - wall.width / 2);
      var distY = Math.abs(y - wall.y - wall.height / 2);

      // проверяем, находится ли центр шара внутри границ стены
      if (distX <= wall.width / 2 + radius && distY <= wall.height / 2 + radius) {
        // произошло столкновение со стеной, определяем направление отскока

        // определяем сторону стены, с которой произошло столкновение
        var overlapX = wall.width / 2 - distX;
        var overlapY = wall.height / 2 - distY;
        
        // проверяем, находится ли шарик внутри стены
        if (overlapX >= 0 && overlapY >= 0) {
          if (overlapX < overlapY) {
            // столкновение произошло со стороной стены (отскок по горизонтали)
            if (x < wall.x + wall.width / 2) {
              // шар столкнулся с левой стороной стены
              x = wall.x - radius;
            } else {
              // шар столкнулся с правой стороной стены
              x = wall.x + wall.width + radius;
            }
            dx = -dx * bounce;
          } else {
            // столкновение произошло с верхней или нижней стороной стены (отскок по вертикали)
            if (y < wall.y + wall.height / 2) {
              // шар столкнулся с верхней стороной стены
              y = wall.y - radius;
      dx = dx * (1 - friction);
            } else {
              // шар столкнулся с нижней стороной стены
              y = wall.y + wall.height + radius;
}
dy = -dy * bounce;
}
} else {
// столкновение произошло с углом стены (отскок по диагонали)
if (overlapX < overlapY) {
// отскок по горизонтали
if (x < wall.x + wall.width / 2) {
// шар столкнулся с левой стороной стены
x = wall.x - radius;
} else {
// шар столкнулся с правой стороной стены
x = wall.x + wall.width + radius;
}
dx = -dx * bounce;
} else {
// отскок по вертикали
if (y < wall.y + wall.height / 2) {
// шар столкнулся с верхней стороной стены
y = wall.y - radius;
      dx = dx * (1 - friction);
} else {
// шар столкнулся с нижней стороной стены
y = wall.y + wall.height + radius;
}
dy = -dy * bounce;
}
}
}
}
else if (wall.shape === "triangle")
{
// определяем столкновение с треугольниками
    // определяем вершины треугольника
    var triangle = new SAT.Polygon(new SAT.Vector(wall.x, wall.y), [
      new SAT.Vector(wall.points[0].x, wall.points[0].y),
      new SAT.Vector(wall.points[1].x, wall.points[1].y),
      new SAT.Vector(wall.points[2].x, wall.points[2].y)
    ]);
    // определяем круг
    var circle = new SAT.Circle(new SAT.Vector(x, y), radius);
    // проверяем столкновение
    var response = new SAT.Response();
    var collided = SAT.testCirclePolygon(circle, triangle, response);
    if (collided) {
      // произошло столкновение со стеной, определяем направление отскока
      var overlap = response.overlapV;
      var normal = response.overlapN;
      // отбрасываем шарик на расстояние, равное перекрытию

      // отражаем скорость шарика относительно нормали стены
      var dot = dx * normal.x + dy * normal.y;
      dx = (dx - 1.9 * dot * normal.x) * (1 - friction);
      dy = (dy - 1.9 * dot * normal.y) * (1 - friction);
    }
}
else if (wall.shape === "dynamite")
{
      // определяем расстояние от центра шара до границы стены
      var distX = Math.abs(x - wall.x - wall.width / 2);
      var distY = Math.abs(y - wall.y - wall.height / 2);

      // проверяем, находится ли центр шара внутри границ стены
      if (distX <= wall.width / 2 + radius && distY <= wall.height / 2 + radius) {
        // произошло столкновение со стеной, определяем направление отскока

        // определяем сторону стены, с которой произошло столкновение
        var overlapX = wall.width / 2 - distX;
        var overlapY = wall.height / 2 - distY;
        
        // проверяем, находится ли шарик внутри стены
        if (overlapX >= 0 && overlapY >= 0) {
          if (overlapX < overlapY) {
            // столкновение произошло со стороной стены (отскок по горизонтали)
            if (x < wall.x + wall.width / 2) {
              // шар столкнулся с левой стороной стены
              x = wall.x - radius;
            } else {
              // шар столкнулся с правой стороной стены
              x = wall.x + wall.width + radius;
            }
            dx = -dx * bounce*10;
          } else {
            // столкновение произошло с верхней или нижней стороной стены (отскок по вертикали)
            if (y < wall.y + wall.height / 2) {
              // шар столкнулся с верхней стороной стены
              y = wall.y - radius;
            } else {
              // шар столкнулся с нижней стороной стены
              y = wall.y + wall.height + radius;
}
dy = -dy * bounce*10;
}
walls.splice(i, 1); // удаляем динамит из массива стен
i--;
numWalls--;
}
}
}
	}

    // останавливаем шар, если он почти не двигается
    if (Math.abs(dx) < 0.1) {
      dx = 0;
    }
    if (Math.abs(dy) < 0.1) {
      dy = 0;
    }
  }
}

// функция рисования круга
function drawCircle() {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
  ctx.fillStyle = "red";
  ctx.fill();
}

// запуск игры
init();